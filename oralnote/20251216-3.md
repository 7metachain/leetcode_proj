# LeetCode 3: Longest Substring Without Repeating Characters — Summary

---

## Problem

Given a string `s`, find the length of the **longest substring without repeating characters**.

---

## Core Insight

> **The longest substring is NOT "the final window left at the end", but "the maximum valid window encountered during traversal".**

This means:
- At every step, if the current window is valid (no duplicates), immediately update the answer.
- Even if the window shrinks later, the answer has already been recorded.

---

## Sliding Window Rules

1. Maintain a window `[left, right]` with **no duplicate characters**.
2. `right` always moves forward.
3. `left` only moves forward—**never backward**.

When `right` points to character `c`:
- If `c` is NOT in the current window → expand
- If `c` IS in the window → window becomes invalid → move `left` to `last[c] + 1`

---

## Why `left = max(left, last[c] + 1)`?

To prevent `left` from moving backward.

Example: `abba`
- When processing the final `a`, the previous `a` was at index 0
- But `left` is already at 2 (due to handling `b`)
- We must NOT pull `left` back to 1

**Rule: left can only go right, never back.**

---

## Three Questions to Verify Understanding

1. Why must we immediately move `left` when a duplicate is found?
2. Why can `left` only move right, never backward?
3. Why won't the longest substring be lost when `left` moves?

---

## One-Liner Takeaway

> **Use a hash map to track each character's last position; on duplicate, jump `left` forward—never backward. Update the answer at every valid step.**

