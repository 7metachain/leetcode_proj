Today I worked through two classic algorithm problems, and what really stood out was how my first instincts were much more “brute force,” while the final solutions were all about choosing the right data structure and the right representation.

**The first problem was “Group Anagrams.”**
At the beginning, I didn’t immediately think of using a hash map. My instinctive approach was pretty straightforward: I wanted to build a “list of lists” as the final result. Then, for each word in the original array, I would compare it against the *first word* of every existing group to check: “Are these two words anagrams?”
To make that work, I would need an extra function to test whether two words are anagrams — maybe by sorting both words or by counting characters — and then I’d repeat that comparison again and again as I loop through the input.

But the more I thought about it, the more I realized this approach is complicated and inefficient. You end up doing too many repeated comparisons, and the logic becomes messy.

The cleaner approach is to **use a hash map**, where the key idea is: *all anagrams should share the same key*.
There are multiple ways to build that key. For example:

* You can use a **character frequency signature** (like counts of 26 letters), or
* You can **sort the word’s letters** and use the sorted string as the canonical form.

I used the sorting idea: if “eat,” “tea,” and “ate” are all sorted into “aet,” then “aet” becomes the shared key. Every time I see the same key, I push the original word into the same bucket (the value list) in the hash map. Finally, I return all the value lists as the grouped result. 

**The second problem was “Longest Consecutive Sequence.”**
This one gives you an array of integers, and you need the length of the longest run of consecutive natural numbers. Duplicates shouldn’t count multiple times.

My most direct thought was: “Okay, sort the array, remove duplicates, and then scan for the longest consecutive stretch.” That’s a reasonable starting point — but I got stuck on the implementation details. Conceptually it’s easy to *see* the longest consecutive run, but when you try to compute it, it’s tempting to do something clumsy like:

* Start from each number,
* Try to build a sequence by checking +1, +2, +3…
* And repeat this for many starting points.

That quickly turns into nested loops and unnecessary work.

The more elegant solution is to **use a set**. A set gives you two big wins:

1. It automatically removes duplicates.
2. It gives you fast “does this number exist?” lookups.

The key insight is: **only start counting when you are at the beginning of a sequence.**
So for a number `x`, I check whether `x - 1` exists in the set. If it does, that means `x` is not the start — it’s somewhere in the middle — and I skip it.
If `x - 1` does *not* exist, then `x` is a true starting point. From there, I keep checking `x + 1`, `x + 2`, `x + 3`, and so on, until the chain breaks. I record that length, and keep the maximum across all starts.

This way, instead of repeatedly re-scanning the same sequences, I only expand from valid start points, which makes the process much smarter and typically linear-time overall. 

**Overall, these two problems taught me a similar lesson in two different forms:**

* For anagrams, the trick is finding a **canonical representation** so that “different-looking inputs” map to the same key.
* For consecutive sequences, the trick is using **constant-time membership checks** and avoiding redundant work by only starting from the left boundary.

And in both cases, once the representation and data structure are right, the solution becomes surprisingly clean.
